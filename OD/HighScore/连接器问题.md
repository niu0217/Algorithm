# 连接器问题

## 题目

[147、连接器问题](https://sars2025.blog.csdn.net/article/details/131968891?ydreferer=aHR0cHM6Ly9zYXJzMjAyNS5ibG9nLmNzZG4ubmV0L2FydGljbGUvZGV0YWlscy8xMjQyMDQ1OTQ%3D)

## 代码

### 示例

```c++
输入
[1,2],[3,5],[7,10],[15,20],[30,100]
[5,4,3,2,1]






输出
2


说明：
无重叠和相邻，使用1,2，5三个连接器连接后只剩下[1,20],[30,100]

```

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>

std::vector<int> getArr(std::string& input) {
    std::vector<int> arr;
    std::istringstream iss(input);
    std::string number;
    // 通过逗号分隔字符串，将每个数字解析并添加到arr中
    while (std::getline(iss, number, ',')) {
        arr.push_back(std::stoi(number));
    }
    return arr;
}

int main() {
    std::string regionsStr, linksStr;
    // 输入两行数据，第一行代表regionsStr，第二行代表linksStr
    std::getline(std::cin, regionsStr);
    std::getline(std::cin, linksStr);

    // 删除regionsStr和linksStr中的方括号，因为输入的数据是用方括号括起来的
    regionsStr.erase(std::remove(regionsStr.begin(), regionsStr.end(), '['), regionsStr.end());
    regionsStr.erase(std::remove(regionsStr.begin(), regionsStr.end(), ']'), regionsStr.end());
    linksStr.erase(std::remove(linksStr.begin(), linksStr.end(), '['), linksStr.end());
    linksStr.erase(std::remove(linksStr.begin(), linksStr.end(), ']'), linksStr.end());

    // 将输入的字符串转换为对应的整数数组
    std::vector<int> regionsArr = getArr(regionsStr);
    std::vector<int> linksArr = getArr(linksStr);

    // 将regionsArr中的数据按两个数字一组，构成一个二维数组regions，表示一些区间
    std::vector<std::vector<int>> regions;
    for (size_t i = 0; i < regionsArr.size(); i += 2) {
        int left = regionsArr[i];
        int right = regionsArr[i + 1];
        regions.push_back({ left, right });
    }

    // 对regions按照区间的左端点进行升序排序，如果左端点相同，则按右端点升序排序
    std::sort(regions.begin(), regions.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        if (b[0] == a[0]) {
            return a[1] < b[1];
        }
        return a[0] < b[0];
    });

    // 计算相邻区间之间的间隙，并将间隙存储在gaps中
    std::vector<int> gaps;
    std::vector<int> region;
    for (const auto& next : regions) {
        if (!region.empty()) {
            int gap = next[0] - region[1];
            gaps.push_back(gap);
        }
        region = next;
    }

    // 对gaps进行升序排序
    std::sort(gaps.begin(), gaps.end());
    // 对linksArr进行升序排序
    std::sort(linksArr.begin(), linksArr.end());

    int i = 0; // gaps的索引
    int j = 0; // linksArr的索引
    // 使用双指针法，将gaps和linksArr中的元素进行比较，找出有多少个gaps没有被linksArr中的元素所覆盖
    while (i < static_cast<int>(gaps.size()) && j < static_cast<int>(linksArr.size())) {
        if (linksArr[j] >= gaps[i]) {
            gaps[i] = 0;
            i++;
            j++;
        } else {
            j++;
        }
    }

    // 统计没有被linksArr所覆盖的gaps的数量，加1是因为最后一个gap无法被比较，它总是有效的
    int noneZeroNum = 0;
    for (int g : gaps) {
        if (g > 0) {
            noneZeroNum++;
        }
    }

    // 输出结果，表示有多少个没有被linksArr覆盖的间隙
    std::cout << noneZeroNum + 1 << std::endl;

    return 0;
}
```

