# 生成哈夫曼树

## 题目

[454、生成哈夫曼树](https://sars2025.blog.csdn.net/article/details/135246805)

## 代码

```c++
#include<iostream>
#include<vector>
#include<queue>
#include<map>
#include<unordered_map>

using namespace std;

struct TreeNode {
    int weight;
    TreeNode* left;
    TreeNode* right;
    TreeNode() {

    }
    TreeNode(int eweight, TreeNode* eleft = nullptr, TreeNode* eright = nullptr)
        : weight{eweight}, left{eleft}, right{eright} { }
};

struct Compare {
    bool operator() (const TreeNode* lhs, const TreeNode* rhs) {
        return lhs->weight > rhs->weight; //小顶堆
    }
};


class HaffumanTree {
public:
    TreeNode* root;
public:
    HaffumanTree() {
        root = nullptr;
    }
    void buildHuffmanTree(vector<int>& weightVec) {
        //按节点权值构建小顶堆的优先级队列
        priority_queue<TreeNode*, vector<TreeNode*>, Compare> priqueofTree;
        for(int i = 0; i < weightVec.size(); i++) {
            priqueofTree.push(new TreeNode(weightVec[i]));
        }
        while(priqueofTree.size() > 1) {
            TreeNode* leftTree = priqueofTree.top();
            priqueofTree.pop();
            TreeNode* rightTree = priqueofTree.top();
            priqueofTree.pop();
            int curWeight = leftTree->weight + rightTree->weight;
            priqueofTree.push(new TreeNode(curWeight, leftTree, rightTree));
        }
        root = priqueofTree.top();
        priqueofTree.pop();
    }
    void midTraversal(TreeNode* root, vector<int>& result) {
        if(root == nullptr) {
            return;
        }
        midTraversal(root->left, result);
        result.push_back(root->weight);
        midTraversal(root->right, result);
    }
};

int main()
{
    int m;
    cin>>m;
    vector<int> weightVec(m, 0);
    for(int i = 0; i < m; i++) {
        cin>>weightVec[i];
    }

    HaffumanTree* haffmanTree = new HaffumanTree();
    haffmanTree->buildHuffmanTree(weightVec);
    vector<int> result;
    haffmanTree->midTraversal(haffmanTree->root, result);
    for(int value : result) {
        cout<<value<<" ";
    }
    cout<<endl;
}
```

