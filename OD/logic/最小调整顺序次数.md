# 最小调整顺序次数

## [题目描述](https://blog.csdn.net/m0_47384542/article/details/131880445)

## 代码

### 自己

```c++
#include<iostream>
#include<algorithm>
#include<deque>
#include<vector>
#include<string>
#include<sstream>

using namespace std;

vector<string> getOneOperation(string& s) {
    istringstream iss(s);
    vector<string> result;
    string word;
    while(iss>>word) {
        result.push_back(word);
    }
    return result;
}

int main()
{
    string number;
    getline(cin, number); //这里不能使用cin，会出错
    int n = stoi(number);
    vector<vector<string>> operations;
    int size = 2 * n;
    for(int i = 0; i < size; i++) {
        string s;
        getline(cin, s);
        operations.push_back(getOneOperation(s));
    }

    deque<int> numberDeq;
    int start = 1;
    int minTime = 0;
    for(int i = 0; i < operations.size(); i++) {
        vector<string> strVec = operations[i];
        if(strVec[0] == "remove") {
            if(numberDeq.front() == start) {
                numberDeq.pop_front();
                start++;
            }
            else {
                sort(numberDeq.begin(), numberDeq.end());
                numberDeq.pop_front();
                minTime++;
                start++;
            }
        }
        else if(strVec[1] == "add") {
            if(strVec[0] == "head") {
                numberDeq.push_front(stoi(strVec[2]));
            }
            else {
                numberDeq.push_back(stoi(strVec[2]));
            }
        }
    }
    cout<<minTime<<endl;
}
```

### 官方

```c++
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
#include<bitset>
using namespace std;
 
vector<string> split(string input_str) {
    //空格分割
    vector<string> v;
    while (input_str.find(" ") != string::npos) {
        int found = input_str.find(" ");
        v.push_back(input_str.substr(0, found));
        input_str = input_str.substr(found + 1);
    }    
    v.push_back(input_str);
    return v;
}
 
int main() {
    string input_number;
    getline(cin,input_number);
    int number = stoi(input_number);
 
    vector<vector<string>> operations;
    for (int i =0;i<2*number;i++) {
        string input_str;
        // 带空格的字符串输入
        getline(cin,input_str);
        operations.push_back(split(input_str));
    }
  
    deque<int> num_deque;
    int start = 1;
    int count = 0;//这个是移动次数
    for(int j = 0;j<operations.size();j++){
        vector<string> strs = operations[j];
       
        //如果是移除指令
        if(strs[0] == "remove") {
            if(!num_deque.empty()){
                if(num_deque.front()==start){
                    //如果队列不为空，且移除来的就是start那么可以移除
                    num_deque.pop_front();
                    start++;
                }else{
                    //此时就需要移动了
                    sort(num_deque.begin(), num_deque.end());
                    num_deque.pop_front();
                    count++;
                    start++;
                }
            }
            continue;
        }
 
        //如果是添加指令
        if(strs[1] == "add") {
            if(strs[0] == "head") {
                //从头部添加
                num_deque.push_front(stoi(strs[2]));
            }else{
                //从尾部添加
                num_deque.push_back(stoi(strs[2]));
            }
        }
            
    }
    cout <<count;
    
 
 return 0;
}
```

