# 单项链表中间节点

## 题目描述

题目描述
求单向链表Q中间的节点值，如果奇数个节点取中间，偶数个取偏右边的那个值。

输入描述：
第一行链表头节点地址path后续输入的节点数n。
后续输入每行表示一个节点，格式："节点地址 节点值 下一个节点地址（-1表示空指针）"输入保证链表不会出现环，并且可能存在一些节点不属于链表。

输出描述：
链表中间节点值。

测试用例：
输入：

```
00010 4
00000 3 -1 
00010 5 12309 
11451 6 00000 
12309 7 11451 
```

输出：6

## 解题思路

1：第一步，根据输入，构建一个输入节点的列表，用map来保存。
2：第二步，根据输入的头节点，先遍历一次，剔除无效节点并记录链表长度size。
3：第三步，找下标为size/2的节点。

## 代码

```c++
#include<iostream>
#include<string>
#include<vector>
#include<unordered_map>

using namespace std;

struct ListNode {
    int val;
    int next;
    ListNode(int val, int next)
        : val{val}, next{next} { }
};

int main()
{
    //key:   当前链表节点的地址
    //value: 当前链表节点
    unordered_map<int, ListNode*> umap;
    int headAddr;
    int n;
    cin>>headAddr>>n;
    for(int i = 0; i < n; i++) {
        int addr;
        int val;
        int next;
        cin>>addr>>val>>next;
        umap[addr] = new ListNode(val, next);
    }

    //求有效的链表的长度
    int listSize = 1;
    ListNode* curNode = umap[headAddr];
    while(curNode->next != -1) {
        listSize++;
        curNode = umap[curNode->next];
    }

    //求中间节点的值
    int cur = 0;
    curNode = umap[headAddr];
    while(curNode->next != -1) {
        if(listSize / 2 == cur) {
            cout<<curNode->val<<endl;
            return 0;
        }
        cur++;
        curNode = umap[curNode->next];
    }
}
```

