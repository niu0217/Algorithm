# 过河

## 题目链接

[143、羊、狼、农夫过河](https://blog.csdn.net/m0_47384542/article/details/131968322)

## 代码

### 自身

```c++
#include<iostream>
#include<climits>
#include<vector>

using namespace std;

int getTransportTime(int m0, int n0, int x, int m1, int n1, int times, int minTimes) {
    //船的容量够大，则一次全运走
    if(m0 + n0 <= x) {
        return times + 1;
    }
    //i: 船上的羊的数量
    //j: 船上的狼的数量
    //农夫在的时候，狼不会攻击羊，所以船上没有羊的数量必须大于狼的数量的限制
    for(int i = 0; i <= min(m0, x); i++) {
        for(int j = 0; j <= min(n0, x - i); j++) {
            if(i + j == 0) {
                continue;
            }
            if((m0 - i == 0 || m0 - i > n0 - j) &&
               (m0 + i == 0 || m0 + i > n0 + j)) {
                int result = getTransportTime(m0 - i, n0 - j, x, m1 + i, n1 + j, times + 1, minTimes);
                if(result < minTimes && result != 0) {
                    minTimes = result;
                }
            }
        }
    }
    return minTimes;
}

int main()
{
    int m0; //当前岸上羊的数量
    int n0; //当前岸上狼的数量
    int x; //船的容量
    int m1 = 0; //对岸羊的数量
    int n1 = 0; //对岸狼的数量
    int times = 0; //已经运输的次数
    int minTimes = INT_MAX; //目前的最少运输次数

    cin>>m0>>n0>>x;

    int result = getTransportTime(m0, n0, x, m1, n1, times, minTimes);
    if(result == INT_MAX) {
        cout<<0<<endl;
    }
    else {
        cout<<result<<endl;
    }
}
```

### 外部

```c++
#include <iostream>
#include <climits>
#include <algorithm>
using namespace std;

int getTransportTime(int m0, int n0, int x, int m1, int n1, int times, int minTimes) {
    // 若可以一次性运走，结束了
    if (x >= m0 + n0) {
        return times + 1;
    }

    // 尝试运一部分狼一部分羊
    // 要上船的羊数量不可以超过岸上数量、也不可以超过船的容量
    // i: 船上羊的数量
    // j: 船上狼的数量
    for (int i = 0; i <= min(m0, x); i++) {
        // 要上船的狼的数量不可以超过岸上数量、也不可以超过船装了羊后的剩余的容量
        for (int j = 0; j <= min(n0, x - i); j++) {
            // 可以不运
            if (i + j == 0) {
                continue;
            }
            // 船离岸后，原来这岸，要么没有羊，要么羊比狼多，才可以运；对岸也要检查，不考虑回程带动物
            if ((m0 - i == 0 || m0 - i > n0 - j) && (m1 + i == 0 || m1 + i > n1 + j)) {
                // 运一次
                int result = getTransportTime(m0 - i, n0 - j, x, m1 + i, n1 + j, times + 1, minTimes);
                // 如果获取了结果，和minTimes比较，但是不结束，继续检查
                if (result < minTimes && result != 0) {
                    minTimes = result;
                }
            }
        }
    }

    return minTimes;
}

int main() {
    // 读取输入
    int m0, n0, x;
    cin >> m0 >> n0 >> x;
    int m1 = 0, n1 = 0;

    // 初始化最少运输次数为无穷大
    int minTimes = INT_MAX;

    int result = getTransportTime(m0, n0, x, m1, n1, 0, minTimes);

    // 如果步数等于初始化数字，那么代表没找到运输方法
    if (result == INT_MAX) {
        cout << 0 << endl;
    } else {
        cout << result << endl;
    }

    return 0;
}
```

