# 完美走位

## [题目链接](https://blog.csdn.net/m0_47384542/article/details/131967911)

## 代码

```c++
#include<iostream>
#include<vector>
#include<unordered_map>
#include<string>
#include<algorithm>

using namespace std;

int match(const string& s, int index, unordered_map<char, int> umapExcess) {
    char ch = s[index];
    if(umapExcess.find(ch) != umapExcess.end() && umapExcess[ch] > 0) {
        umapExcess[ch]--;
    }
    if(all_of(umapExcess.begin(), umapExcess.end(), [](const auto& charPair) { return charPair.second == 0; })) {
        return index;
    }
    if(index + 1 >= s.size()) {
        return numeric_limits<int>::max();
    }
    return match(s, index + 1, umapExcess);
}

int minReplaceLength(const string& s) {
    //key:   字符
    //value: 该字符出现的次数
    unordered_map<char, int> umapChar {
        {'A', 0},
        {'S', 0},
        {'W', 0},
        {'D', 0}
    };
    for(char ch : s) {
        umapChar[ch]++;
    }

    int target = umapChar.size() / 4;

    //key:   字符
    //value: 该字符比目标值超出了多少
    unordered_map<char, int> umapExcess;
    for(const auto& charPair : umapChar) {
        umapExcess[charPair.first] = max(0, charPair.second - target);
    }

    if(all_of(umapExcess.begin(), umapExcess.end(), [](const auto& charPair) { return charPair.second == 0; })) {
        return 0;
    }

    int result = numeric_limits<int>::max();
    for(int i = 0; i < s.size(); i++) {
        result = min(result, match(s, i, umapExcess) - i + 1);
    }
    return result;
}

int main()
{
    string s;
    cin>>s;
    int result = minReplaceLength(s);
    cout<<result<<endl;
}
```

