# 字符串重新排序

## [题目链接](https://blog.csdn.net/m0_47384542/article/details/131985574)

## 代码

### 自己

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<string>
#include<unordered_map>
#include<sstream>

using namespace std;

bool compare(pair<string, int>& lhs, pair<string, int>& rhs) {
    //次数不相同
    if(lhs.second != rhs.second) {
        return lhs.second > rhs.second;
    }
    //长度不相同
    if(lhs.first.size() != rhs.first.size()) {
        return lhs.first.size() < rhs.first.size();
    }
    //次数和长度都相同
    return lhs.first < rhs.first;
}

int main()
{
    vector<string> words;
    string s;
    getline(cin, s);
    istringstream iss(s);
    string word;
    while(iss>>word) {
        words.push_back(word);
    }

    //单词间按照字典序排序
    vector<string> sortedWords;
    for(string word : words) {
        sort(word.begin(), word.end());
        sortedWords.push_back(word);
    }

    //key:    单词
    //value:  该单词出现的次数
    unordered_map<string, int> umapTimes;
    for(string word : sortedWords) {
        umapTimes[word]++;
    }

    vector<pair<string, int>> sortedTimes(umapTimes.begin(), umapTimes.end()) ;
    sort(sortedTimes.begin(), sortedTimes.end(), compare);

    vector<string> processedWords;
    for(auto p : sortedTimes) {
        string word = p.first;
        int cnt = p.second;
        for(int i = 0; i < cnt; i++) {
            processedWords.push_back(word);
        }
    }

    string result = "";
    for(int i = 0; i < processedWords.size(); i++) {
        if(i != processedWords.size() - 1) {
            result = result + processedWords[i] + " ";
        }
        else {
            result = result + processedWords[i];
        }
    }
    cout<<result<<endl;
}
```

### 官方

```c++
// Online C++ compiler to run C++ program online
#include<iostream>
#include<vector>
#include<algorithm>
#include<iomanip>
#include<string>
#include<exception> 
#include<map>
using namespace std;
 
bool comp(pair<string, int> a, pair<string, int> b) {
    //次数降序、长度升序、字典序排列升序
    if (a.second > b.second) {
        return true;
    } else if(a.second == b.second) {
        if (a.first.size() > b.first.size()) {
            return false;
        } else if (a.first.size() == b.first.size()) {
            return a.first < b.first;
        } else {
            return true;
        }
    } else {
        return false;
    }
}
 
int main() {
    string input_str;
    // 带空格的字符串输入
    getline(cin,input_str);
    
    //空格分割
    vector<string> v;
    while (input_str.find(" ") != string::npos) {
        int found = input_str.find(" ");
        v.push_back(input_str.substr(0, found));
        input_str = input_str.substr(found + 1);
    }    
    v.push_back(input_str);
    
    //第一步，单词内部调整
    for (int i=0;i<v.size();i++) {
        sort(v[i].begin(), v[i].end());
    }
 
    //第二步，单词间调整
    //先统计每个单词出现的次数
    map<string, int> str_count;
    for (int i=0;i<v.size();i++) {
        if (str_count.count(v[i])) {
            str_count[v[i]] += 1;
        } else {
            str_count[v[i]] = 1;
        }
    }
 
    // 排序
    vector<pair<string, int>> str_count_vec;
    for (auto x : str_count) {
        str_count_vec.push_back(x);
    }
    sort(str_count_vec.begin(), str_count_vec.end(), comp);
 
    for (int i=0;i<str_count_vec.size();i++) {
        for (int j=0;j<str_count[str_count_vec[i].first];j++) {
            cout << str_count_vec[i].first << " ";
        }
    }
    return 0;
}
```

